# 数据库的并发事务和锁

## 并发事务带来的问题

### 脏读（未提交读）

事务A读取到另一个B事务还没有提交的数据，如果事务B产生回滚，事务A脏读。

### 丢失更新

两个不同事务同时获得相同的数据，然后在各自事务中修改了该数据，那么先提交的事务更新会被后提交的事务的更新覆盖。

### 不可重复读

事务A在执行过程中，如果自己没有修改，但是多次读取同一个数据的结果出现不一致，叫不可重复读。

### 幻读

事务A读的时候读出了15条数据，这时事务B又插入一条数据，事务A再读的时候就变成了16条，这种情况叫幻读。

## 事务隔离级别与锁

**排他锁 写锁** 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其它锁，也不能读取和修改该对象。  
**共享锁 读锁** 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。对共享锁，如果两个事务对同一个资源上了共享锁，事务A想更新数据，必须等待事务B释放其共享锁。  

| 隔离级别 | 脏读 | 丢失更新 | 不可重复读 | 幻读 |
| -- | -- | -- | -- | -- |
| Read Uncommited | 是 | 是 | 是 | 是 |
| Read Commited | 否 | 是 | 是 | 是 |
| Repeatable Read | 否 | 否 | 否 | 是 |
| Serializable | 否 | 否 | 否 | 否 |

Oracle默认是Read Commited，Mysql默认是Repeatable Read。

## MVCC多版本并发控制

MVCC解决的问题是读写互相不阻塞的问题。  
MVCC只在Repeatable Read和Read Commited（中间两个）两个隔离级别下工作。  
MVCC其实就是在每一行记录的后面增加两个隐藏列，DATA_TRX_ID（记录最近更新这条行记录的事务 ID）和DATA_ROLL_PTR（表示指向该行回滚段的指针）。  
在多个事务并行操作某行数据的情况下，不同事务对该行数据的UPDATE会产生多个版本，然后通过回滚指针组织成一条Undo Log链。  
Read Committed、Repeatable Read两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。  
RC、RR这两个隔离级别的一个很大不同就是生成ReadView（快照）的时间点不同，RC在每一次SELECT语句前都会生成一个ReadView，事务期间会更新，因此在其他事务提交前后所得到的m_ids列表可能发生变化，使得先前不可见的版本后续又突然可见了。而RR只在事务的第一个SELECT语句时生成一个ReadView，事务操作期间不更新。

## Next-Key锁与幻读

临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。

在行级锁定中，InnoDB 使用一个名为next-key locking的算法。InnoDB以这样一种方式执行行级锁定：当它搜索或扫描表的索引之时，它对遇到的索引记录设置共享或独占锁定。因此，行级锁定事实上是索引记录锁定。  
InnoDB对索引记录设置的锁定也映像索引记录之前的“间隙”。如果一个用户对一个索引上的记录R有共享或独占的锁定，另一个用户 不能紧接在R之前以索引的顺序插入一个新索引记录。这个间隙的锁定被执行来防止所谓的“幽灵问题”。假设你想要从有一个标识符值大于100的子表读并锁定所有子记录，并想着随后在选定行中更新一些列：

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

假设在id列有一个索引。查询从id大于100的第一个记录开始扫描。如果设置在索引记录上的锁定不把在间隙生成的插入排除在外，一个新行可能与此同时被插进表中。如果你在同一事务内执行同样的SELECT，你可能会在该查询返回的结果包里看到一个新行。这与事务的隔离原则是相反的：一个事务应该能够运行，以便它已经读的数据在事务过程中不改变。如果我们把一套行视为数据项，新的“幽灵”子记录可能会违反这一隔离原则。  
当InnoDB扫描一个索引之时，它也锁定所以记录中最后一个记录之后的间隙。刚在前一个例子中发生：InnoDB设置的锁定防止任何插入到id可能大过100的表。
