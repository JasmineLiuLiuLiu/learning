# 代理模式

代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问。

抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

代理有静态代理和动态代理。




静态代理和装饰器的区别
/静态代理类

//静态代理类与装饰者之间的共同点：

//（1）都要实现与目标类相同的业务接口（2）在俩个类中都要声明目标对象（3）都可以在不修改目标类的前提下增强目标方法

//静态代理类与装饰者，之间的不同点：

//（1）目的不同，装饰者，简单说，就是为了增强目标对象

// 静态代理的使用目的是为了保护和隐藏目标对象

//（2）对于目标对象的获取方式不同

//装饰者中目标对象的获取，通过代参构造器传入，静态代理类中，是在无参构造器中直接创建。

//(3)功能增强的实现者不同 装饰者设计模式中存在装饰者基类，其并不能实现增强，而是由具体的装饰者进行增强的，所以其存在着"装饰者链"

//而静态代理中，一般不存在父子类的关系，具体的增强，就是由代理类实现的。无需其子类完成，所以不存在 链 的概念。
————————————————
版权声明：本文为CSDN博主「Sher__」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_35609314/article/details/78913635