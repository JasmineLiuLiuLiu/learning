# equals，==，hashCode，常量池，包装类缓存等

## 1 堆、栈、常量池

简单说来，`new`出来的对象都是放到**堆**中，注意是对象的内容，而对应的引用（地址）存放在**栈**中。
比如  `String str = new String("abc");`，其中`str`的内容`abc`就存放在堆中，而我们怎么访问到堆中的数据呢，这就需要一个引用，即`abc`存放在堆中的地址，而这个地址就存放在栈中，通过栈中的地址就能够访问到堆中的内容，而栈的地址我们是无法获知的。  
所以我们访问`str`的过程是先从栈中找到`str`的地址，然后在堆中查找这个地址对应的内容。  
而我们在编程序的时候貌似不会这么写，一般都简写为：`String str = "abc";`，JVM会按如下步骤去做：

1. 首先在栈中生成一个str的空引用。
2. 查看常量池中是否存在“abc”，如果有就不新建。如果不存在，则在常池中新创建一个。最后更新引用，指向常量池中的"abc"。

**常量池**是在编译时就能够确定的值，包括字符串，整数，然后直接写到class文件中。  

* 对于基本类型的包装类：`Byte`，`Short`，`Integer`，`Long`，`Character`，`Boolean`，当值在-128 ~ 127之间时，会存放到常量池 *[jasmine:实际是一个 static cache]*中，而对于浮点数和其他整数则存放到堆中。
* 对于基本数据类型：`int`，`short`，`long`，`byte`, `float`, `double`, `boolean`, `char`，为了追求速度，其引用和数值都直接存放到栈中。与常量池相同，如果定义两个相同值的变量，栈中只会保存一份数据。

## 2. equals

`equals()`的作用是用来判断两个对象是否相等。  
`equals()`定义在JDK的`Object.java`中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

既然`Object.java`中定义了`equals()`方法，这就意味着所有的Java类都实现了`equals()`方法，所有的类都可以通过`equals()`去比较两个对象是否相等。 但是，我们已经说过，使用默认的`equals()`方法，等价于`==`方法。因此，我们通常会重写`equals()`方法：若两个对象的内容相等，则`equals()`方法返回`true`；否则，返回`fasle`。  

### 1.1 equals的规则（从14的Object equals的javadoc翻译）

`equals`方法实现了对非空对象引用的等价关系:

* 它是自反的:对于任何非空的参考值`x`, `x.equals(x)`应该返回`true`。
* 它是对称的:对于任何非空的参考值`x`和`y`, `x.equals(y)`应该返回`true`当且仅当`y.equals(x)`返回`true`。
* 它是可传递的:对于任何非空参考值`x`, `y`和`z`，如果`x.equals(y)`返回`true`, `y.equals(z)`返回`true`，那么`x.equals(z)`应该返回`true`。
* 它是一致的:对于任何非空的参考值`x`和`y`，多次调用`x.equals(y)`都会返回`true`或`false`，前提是在对象的等号比较中使用的信息没有被修改。
* 对于任何非空参考值`x`, `x.equals(null)`应该返回`false`。
`Object`类的`equals`方法实现了对象上最有区别性的等价关系;也就是说，对于任何非空参考值`x`和`y`，当且仅当`x`和`y`指向同一个对象(`x == y`的值为`true`)时，该方法返回`true`。
请注意，不管何时，只要覆盖了`equals`方法，有必要覆盖`hashCode`方法，以便维护`hashCode`方法的通用契约，该契约声明相等的对象必须具有相等的哈希码。

## 3. ==

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。

## 34. hashCode

`hashCode()`的作用是获取哈希码，也称为散列码；它实际上是返回一个`int`整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的`Object`类中，这就意味着 Java 中的任何类都包含有`hashCode()`函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。

```java
public native int hashCode();
```

### 3.1 HashCode作用

我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？  
当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

### 3.2 hashCode跟地址值的关系

* 地址值：内存地址，变量在内存中的位置。JVM虚拟出来的内存地址，不是实际的物理地址。
* 哈希值：如果没有重写`hashCode()`方法，默认使用超类`Object`里的`int hashCode()`，这里返回的值与地址值有一定关系，有时候可能会相等，有时候可能会不等，具体取决于运行时库和JVM的具体实现，我们可以看成是一个逻辑地址。  
  另一种就是重写了`hashCode()`方法，这里就是利用到了各种算法得到的哈希值，比如`String`类、包装类等都重写了`hashCode()`方法，我们也可以对我们自己写的类重写这个方法，使得它返回一个我们要的值，甚至一直返回一个值都可以，只要我们想要即可。  
  注意，对于第一种没有重写`hashCode()`方法得到的哈希值，因为与地址值有关，所以得到的哈希值是不会相等的。而对于重写了`hashCode()`方法得到的哈希值，由于算法的缘故，所以是可能存在相等的，这个也叫做**哈希碰撞**。  

### 3.3 HashCode契约（从14的Object hashCode的javadoc翻译）

在Java应用程序的执行过程中，每当在同一个对象上多次调用`hashCode`方法时，只要在对象的相等比较中使用的信息没有被修改，该方法就必须始终返回相同的整数。这个整数不需要在应用程序的这次执行和另一次执行之间保持一致。  
如果两个对象根据`equals(Object)`方法相等，那么对这两个对象调用`hashCode`方法必须产生相同的整数结果。  
如果两个对象根据`equals(Object)`方法不相等，那么调用这两个对象的`hashCode`方法不是必须产生不同的整数结果的。然而，程序员应该意识到，为不同的对象生成不同的整数结果可能会提高哈希表的性能。

### 3.4 HashCode与equals关系

对于`HashSet`和`HashMap`这些基于散列值（`hash`）实现的类。`HashMap`的底层处理机制是以数组的方法保存放入的数据的(`Node<K,V>[] table`)，其中的关键是数组下标的处理 数组的下标是根据传入的元素`hashCode`方法的返回值再和特定的值异或决定的。如果该数组位置上已经有放入的值了，且传入的键值相等则不处理，若不相等则覆盖原来的值，如果数组位置没有条目，则插入，并加入到相应的链表中。检查键是否存在也是根据`hashCode`值来确定的。所以如果不重写`hashCode`的话可能导致`HashSet`、`HashMap`不能正常的运作。

