# 并发工具类

## 等待多线程完成的`CountDownLatch`（线程计数器）

`CountDownLatch`允许一个或多个线程等待其他线程完成操作，`CountDownLatch`是基于`AQS`的共享模式的使用。

```java
public class CountDownLatch {

    private static final class Sync extends AbstractQueuedSynchronizer { // 继承AQS的抽象类
        Sync(int count) {
            setState(count);
        }

        // CountDownLatch的await方法调用，其实就是判断当前的state变量是否为0
        protected int tryAcquireShared(int acquires) { 
            return (getState() == 0) ? 1 : -1;
        }

        // CountDownLatch的countDown方法调用，当前state变量自减1，再cas进去
        protected boolean tryReleaseShared(int releases) {
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c - 1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }

    private final Sync sync;  // 同步器提供所有实现

    public CountDownLatch(int count) { // 构造函数，需要等待count个点完成
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    public void countDown() {
        sync.releaseShared(1);
    }

    // ...
}

```

## 同步屏障`CyclicBarrier`（回环栅栏-等待至`barrier`状态再全部同时执行）

`CyclicBarrier`字面意思是可循环使用（Cyclic）的屏障（Barrier)。它让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续执行。`CyclicBarrier`利用`ReentrantLock`和`Condition`来实现的。
在`CyclicBarrier`类的内部有一个计数器（`count`），每个线程在到达屏障点的时候都会调用`await`方法将自己阻塞，此时计数器会减1，当计数器减为0的时候所有因调用`await`方法而被阻塞的线程将被唤醒，这就实现一组线程相互等待。

```java
public class CyclicBarrier {

  private static class Generation {

    Generation() {
    }

    boolean broken;
  }

  private final ReentrantLock lock = new ReentrantLock(); // 同步操作锁

  private final Condition trip = lock.newCondition(); // 线程拦截器

  private final int parties; // 每次拦截的线程数，构造函数传入

  // 换代前执行的任务，当count减为0时会将所有阻塞的线程唤醒，
  // 在唤醒所有线程之前你可以通过指定barrierCommand来执行自己的任务
  private final Runnable barrierCommand;

  private Generation generation = new Generation(); // 表示栅栏的当前代，利用它可以实现循环等待

  // 计数器，初始值和parties相同，
  // 以后随着每次await方法的调用而减1，直到减为0就将所有线程唤醒
  private int count;

  //核心等待方法
  private int dowait(boolean timed, long nanos)
      throws InterruptedException, BrokenBarrierException, TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock(); // 先上排它锁
    try {
      final Generation g = generation;
      //检查当前栅栏是否被打翻
      if (g.broken) {
        throw new BrokenBarrierException();
      }
      //检查当前线程是否被中断
      if (Thread.interrupted()) {
        //如果当前线程被中断会做以下三件事
        //1.打翻当前栅栏
        //2.唤醒拦截的所有线程
        //3.抛出中断异常
        breakBarrier();
        throw new InterruptedException();
      }
      //每次都将计数器的值减1
      int index = --count;
      //计数器的值减为0则需唤醒所有线程并转换到下一代
      if (index == 0) {
        boolean ranAction = false;
        try {
          //唤醒所有线程前先执行指定的任务
          final Runnable command = barrierCommand;
          if (command != null) {
            command.run();
          }
          ranAction = true;
          //唤醒所有线程并转到下一代
          nextGeneration();
          return 0;
        } finally {
          //确保在任务未成功执行时能将所有线程唤醒
          if (!ranAction) {
            breakBarrier();
          }
        }
      }

      //如果计数器不为0则执行此循环
      for (; ; ) {
        try {
          //根据传入的参数来决定是定时等待还是非定时等待
          if (!timed) {
            trip.await();
          } else if (nanos > 0L) {
            nanos = trip.awaitNanos(nanos);
          }
        }
      } catch(InterruptedException ie){
        //若当前线程在等待期间被中断则打翻栅栏唤醒其他线程
        if (g == generation && !g.broken) {
          breakBarrier();
          throw ie;
        } else {
          //若在捕获中断异常前已经完成在栅栏上的等待, 则直接调用中断操作
          Thread.currentThread().interrupt();
        }
      }
      // 此时线程已经被唤醒
      //如果线程因为打翻栅栏操作而被唤醒则抛出异常
      if (g.broken) {
        throw new BrokenBarrierException();
      }
      //如果线程因为换代操作而被唤醒则返回计数器的值
      if (g != generation) {
        return index;
      }
      //如果线程因为时间到了而被唤醒则打翻栅栏并抛出异常
      if (timed && nanos <= 0L) {
        breakBarrier();
        throw new TimeoutException();
      }
    } finally {
      lock.unlock();
    }
  }

  // 将栅栏转到下一代，在该方法中会：
  // 1. 唤醒所有等待在trip上的线程
  // 2. 将计数器count的值重新设为parties
  // 3. 重新设置栅栏代次
  private void nextGeneration() {
    trip.signalAll();
    count = parties;
    generation = new Generation();
  }

  // 打破栅栏，该方法会：
  // 1. 设置generation的broken状态为true
  // 2. 唤醒所有等待在trip上的线程
  // 3. 将计数器count的值重新设为parties
  private void breakBarrier() {
    generation.broken = true;
    count = parties;
    trip.signalAll();
  }
}

// ...
```

