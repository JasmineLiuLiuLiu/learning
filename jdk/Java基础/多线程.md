# JAVA多线程并发

## 1. JAVA线程实现/创建方式

### 1.1 继承Thread类

### 1.2 实现Runnable接口

### 1.3 通过Callable和FutureTask创建线程

1. 创建Callable接口的实现类，实现call()方法；
2. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callback对象的call()方法的返回值；
3. 使用FutureTask对象作为Thread对象的target创建并启动新线程；
4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

```java
public class CallableThreadTest implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {

        int i = 0;
        for (i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableThreadTest callableThreadTest = new CallableThreadTest();
        FutureTask<Integer> futureTask = new FutureTask<>(callableThreadTest);
        Thread myThread = new Thread(futureTask);
        myThread.start();
        System.out.println("The future task returns: " + futureTask.get());

    }
}
```

### 1.4 基于线程池

线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。

```java
ExecutorService threadPool = Executors.newFixedThreadPool(10);
while (true) {
    threadPool.execute(new Runnable() { // 提交多个线程任务，并执行
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " is running ..");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
}
```

## 2 4种线程池

`Executors` 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了`ExecutorService` 接口。  
主要有四种：

* `newCachedThreadPool`
* `newFixedThreadPool`
* `newSingleThreadExecutor`
* `newScheduledThreadPool`

### 2.1 `newCachedThreadPool`

创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。

### 2.2 `newFixedThreadPool`

创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

### 2.3 `newScheduledThreadPool`

创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

```java
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
scheduledThreadPool.schedule(new Runnable() {
    @Override
    public void run() {
        System.out.println("延迟三秒");
        }
}, 3, TimeUnit.SECONDS);

scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
        System.out.println("延迟1 秒后每三秒执行一次");
    }
}, 1, 3, TimeUnit.SECONDS);
```

### 2.4 `newSingleThreadExecutor`

Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！
